#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    mgiPot,         sensorPotentiometer)
#pragma config(Sensor, in2,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, in3,    armPot,         sensorPotentiometer)
#pragma config(Sensor, in4,    liftPotRight,   sensorPotentiometer)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           coneGrabber,   tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftFront,     tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           rightFront,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port4,           leftBack,      tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port5,           rightBack,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port6,           goalIntake,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           liftLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           liftRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           liftRight2,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          arm,           tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/






int auton;
void pre_auton(){
	bLCDBacklight = true;
	int current = 1;
	int max = 5;    //Sets the limit on the number of autons
	if(bIfiRobotDisabled) { //This if statement will check if the robot is disabled to prevent the robot from freezing on preauton if the processor accidentally restarts
		while(1==1) {
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDChar(1,0,200);    //These commands set up the user interface on the LCD screen
			displayLCDChar(1,15,199);
			displayLCDString(1,5,"Enter");
			if(current == 1) {          //This set of if statements displays the name of the currently viewed auton option
				displayLCDCenteredString(0,"Auton-1");
			}
			if(current == 2) {
				displayLCDCenteredString(0,"Auton-2");
			}
			if(current == max) {
				displayLCDString(0,1,"Battery Voltage");
			}

			displayLCDNumber(0,0,current);
			while(nLCDButtons == 0){wait1Msec(5);}   //This loop will wait until a button is pressed
			if(nLCDButtons == 4) {      //This set of if statements checks which button is pushed
				if(current != max) {       //This if statement prevents the current variable from passing the limit of autons, resetting to 0 at the maximum
					current++;
					} else {
					current = 1;
				}
				} else if (nLCDButtons == 2) {  //This if statement will select the currently viewed auton
				auton = current;
				break;
				} else if (nLCDButtons == 1) {  //This if statement prevents the current variable from going below 0, resetting to the maximum at 0
				if(current != 1) {
					current--;
					} else {
					current = max;
				}
			}
			while(nLCDButtons != 0){wait1Msec(5);}    //This loop will wait until all buttons are released
		}
		while(nLCDButtons !=0){wait1Msec(5);}
		if (auton == max) {     //An added auton for viewing battery voltage
			while(nLCDButtons != 2){
				clearLCDLine(0);
				clearLCDLine(1);
				displayLCDCenteredString(1,"Exit");
				//Display the Primary Robot battery voltage
				string mainBattery;
				displayLCDString(0, 0, "Primary: ");
				sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
				displayNextLCDString(mainBattery);
				wait1Msec(100);
			}
			while(nLCDButtons != 0) {wait1Msec(5);}
			pre_auton();
		}
	}
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
//moves the secondary lift up
void secondaryLiftUp(int armUpPower, int armUpPosition){
	if (SensorValue(armPot) >= armUpPosition){
		while(SensorValue(armPot) > armUpPosition){
			motor[arm] = armUpPower;
		}
	}
}
//moves the reachbar down
void secondaryLiftDown (int armDownPower, int armDownPosition) {
	if(SensorValue(armPot) >= armDownPosition){
		while(SensorValue(armPot) > armDownPosition){
			motor[arm] = armDownPower;
		}
	}

}



void pidControl(int basePower,int target) {
	float kP = 1.5;
	float kI = 0.04;
	float kD = 0.05;

	float pidError = 0;
	float lastPidError = 0;

	float pidIntegral = 0;
	float pidDerivative = 0;
	float pidChange = 0;

	motor[port2] = basePower;
	motor[port3] = basePower;
	motor[port4] = basePower;
	motor[port5] = basePower;
	SensorValue(I2C_2) = 0;
	while(abs(SensorValue(I2C_2)) < abs(target)) {
		//Calculate Error
		pidError = getMotorVelocity(port4)-getMotorVelocity(port5);

		//Integral part
		if (abs(pidIntegral) < 50) {
			pidIntegral = pidError - (pidError-lastPidError)/2 + pidIntegral;
			} else {
			pidIntegral = 0;
		}

		//Derivative part
		pidDerivative = pidError - lastPidError;

		//Calculate change
		pidChange = kP*pidError + kI*pidIntegral + kD*pidDerivative;

		lastPidError = pidError;
		if (basePower + pidChange > 128){
			motor[port3] = 128;
			motor[port5] = 128;
			} else if (basePower + pidChange < -128){
			motor[port3] = -128;
			motor[port5] = -128;
			} else {
			motor[port3] = basePower + pidChange;
			motor[port5] = basePower + pidChange;
		}
		wait1Msec(25);
	}
	motor[port2] = 0;
	motor[port3] = 0;
	motor[port4] = 0;
	motor[port5] = 0;
}
// pid point turns
void pidTurn (int pidTurnPower, int pidTurnTarget) {

	float turnP = 1.5;
	float turnI = 0.04;
	float turnD = 0.05;

	float pidTurnError = 0;
	float lastPidTurnError = 0;

	float pidTurnIntegral = 0;
	float pidTurnDerivative = 0;
	float pidTurnChange = 0;

	motor[port2] = pidTurnPower;
	motor[port3] = pidTurnPower;
	motor[port4] = pidTurnPower;
	motor[port5] = pidTurnPower;
	//LeftBack
	SensorValue(I2C_2) = 0;
	//RightBack
	SensorValue(I2C_3) = 0;

	while(abs(SensorValue(I2C_2)) < abs(pidTurnTarget)) {
		//Calculate Error
		pidTurnError = getMotorVelocity(port4)-getMotorVelocity(port5);

		//Integral part
		if (abs(pidTurnIntegral) < 50) {
			pidTurnIntegral = pidTurnError - (pidTurnError-lastPidTurnError)/2 + pidTurnIntegral;
			} else {
			pidTurnIntegral = 0;
		}

		//Derivative part
		pidTurnDerivative = pidTurnError - lastPidTurnError;

		//Calculate change
		pidTurnChange = turnP*pidTurnError + turnI*pidTurnIntegral + turnD*pidTurnDerivative;

		lastPidTurnError = pidTurnError;
		if (pidTurnPower + pidTurnChange > 128){
			motor[port3] = 128;
			motor[port5] = 128;
			} else if (pidTurnPower + pidTurnChange < -128){
			motor[port3] = -128;
			motor[port5] = -128;
			} else {
			motor[port3] = pidTurnPower + pidTurnChange;
			motor[port5] = pidTurnPower + pidTurnChange;
		}
		wait1Msec(25);
	}
	motor[port2] = 0;
	motor[port3] = 0;
	motor[port4] = 0;
	motor[port5] = 0;
}



void MobileUp (int UpPower) {

while(SensorValue(mgiPot) > 1250){
	motor[goalIntake] = UpPower;
}
motor[goalIntake] = 0;
}
void MobileDown (int DownPower){

while(SensorValue(mgiPot) < 2600){
	motor[goalIntake] = -DownPower;
}
motor[goalIntake] = 0;

}



//Toggles the mgi between two states (forward(false) and back(true) )
/*void toggleMobileIntake( int position, int Power, bool foreward, int units, int DrivePower)
{
//If the mgi is in the back position (backPos is true), then we simply move the motors in the normal direction
//If the mgi is in the forward position (backPos is false), then we run the motors in the opposite direction

SensorValue(I2C_1) = 0;
SensorValue(I2C_2) = 0;
SensorValue(I2C_3) = 0;
SensorValue(I2C_4) = 0;


if(SensorValue(mgiPot) >= position){
while(SensorValue(mgiPot) > position){
motor[goalIntake] = Power;
}
}
}

/*	if
SensorValue(I2C_1) = 0;
SensorValue(I2C_2) = 0;
SensorValue(I2C_3) = 0;
SensorValue(I2C_4) = 0;

while(SensorValue(I2C_2) < units){
motor[leftFront] = DrivePower;
motor[leftBack] = DrivePower;
motor[rightFront] = DrivePower;
motor[rightBack] = DrivePower;
}

motor[leftFront] = 0;
motor[leftBack] = 0;
motor[rightFront] = 0;
motor[rightBack] = 0;
}






if (SensorValue(mgiPot) <= position){
while(SensorValue(mgiPot) < position){
motor[goalIntake] = -Power;

}
}

}
*/



//just in case we go back to the cone grabbing claw
/*void releaseCone()
{
motor[coneGrabber] = 50;
}

void pickupCone()
{
motor[coneGrabber] = -50;
}
*/


void releaseCone()
{
motor[coneGrabber] = 120;
}

void pickupCone()
{
motor[coneGrabber] = -120;
}



int target = 2500;

void pointTurn(int power, int units, bool right)
{
//whether or not we are turning to the right determines our modifier.
int modifier = right ? 1 : -1;
//Chris is not doing all too much work today
SensorValue(I2C_2) = 0;
SensorValue(I2C_3) = 0;
if(right){
	while(SensorValue(I2C_2) < units){
		motor[leftFront] = power * modifier;
		motor[leftBack] = power * modifier;
		motor[rightFront] = -power * modifier;
		motor[rightBack] = -power * modifier;
	}
	}else{
	while(SensorValue(I2C_2) > -units){
		motor[leftFront] = power * modifier;
		motor[leftBack] = power * modifier;
		motor[rightFront] = -power * modifier;
		motor[rightBack] = -power * modifier;
	}
}
motor[leftFront] = 0;
motor[leftBack] = 0;
motor[rightFront] = 0;
motor[rightBack] = 0;
}

task keepItHereHomie(){
while(true){
	int direction = 1;
	if(target > SensorValue(liftPot)){
		direction = 1;
		}else if(target < SensorValue(liftPot)){
		direction = -1;
		}else{
		direction = 0;
	}
	motor[liftLeft] = 10 * direction;
	motor[liftRight] = 10 * direction;
	motor[liftRight2] = 10 * direction;
}
}
//this controls the lift, the target is used to make the target to which the lift must reach
void lift(int target)
{
target = target;
stopTask(keepItHereHomie);
int direction = 1;
if(target > SensorValue(liftPot)){
	direction = 1;
	}else if(target < SensorValue(liftPot)){
	direction = -1;
	}else{
	direction = 0;
}
motor[liftLeft] = 127 * direction;
motor[liftRight] = 127 * direction;
motor[liftRight2] = 127 * direction;
while(SensorValue(liftPot) != target)
{
}
motor[liftLeft] = 0;
motor[liftRight] = 0;
motor[liftRight2] = 0;
}
//makes the base go forewards
void move(int power, int units)
{

SensorValue(I2C_1) = 0;
SensorValue(I2C_2) = 0;
SensorValue(I2C_3) = 0;
SensorValue(I2C_4) = 0;

while(SensorValue(I2C_2) < units){
	motor[leftFront] = power;
	motor[leftBack] = power;
	motor[rightFront] = power;
	motor[rightBack] = power;
}

motor[leftFront] = 0;
motor[leftBack] = 0;
motor[rightFront] = 0;
motor[rightBack] = 0;
}

task autonomous()
{
// ten point auton that can work for either side
//hopefully
if (auton == 1) {

	lift(3000);
	//secondaryLiftUp(120, 3000);
	//pidControl(120,2M
	MobileDown(120);
	pidControl (120, 2500);
	MobileUp(120);
	pidControl (-120, 2400);
	pointTurn(120, 1200, true);
	pidControl(120, 500);
	pointTurn(120, 200, true);
	pidControl(120,100);
	MobileDown(120);
	pidControl(-120, 50);
	MobileUp(120);
	pidControl(-120, 700);



	//	MobileDown(360, 120);
	//	secondaryLiftUp(2200, 120);
	//	pointTurn(120, 600, true);
	//	pidControl(120, 3429);
	//	pointTurn(120, 600, true);
	//	lift(75);
	//	pickupCone();
	//	wait1Msec(200);
	//	lift(200);
	//	pidControl(120, 600);
	//	MobileUp(0, 120);
	//	pidControl(120 ,-600);
	//	secondaryLiftDown(1700, 120);
	//	releaseCone();
	//	wait1Msec(200);
	//	pointTurn(-120, 600, false);
	//	pidControl(120, 3000);
	//	pointTurn(120, 200, false);
	//	pidControl(60, 200);
	//  MobileDown(360, 120);
	//	pidControl(120, -200);
	//	setLCDPosition(0,0);

	// work on making the Mobile goal intake work, pls
	// adjust the values as needed
	// make a separate void for lowering the intake and moving it up
	//so that the robot can drive foreward and pick up the goal


	//skills auton
	// set the robot so that it will go for the feild goal on the side of the feild wiht the speed loader
	} else if (auton == 2) {
	lift(200);
	wait1Msec(5);
	secondaryLiftUp(120, 2900);
	wait1Msec(5);
	MobileDown(120);
	wait1Msec(5);
	pidControl(120, 1577);
	MobileUp(120);
	wait1Msec(5);
	//now that the cone has been retreived, we shall bring it to the 20 point zone hopefuly.
	//make sure that the point turn below is a complete 180
	pointTurn(120,  600, true);
	//make the bot move to about the white line, around 25 inches
	pidControl(120, 1228);
	// make sure that this turn is 90 degrees
	wait1Msec(5);
	pointTurn(100, 300, true);
	pidControl(60, 792);
	pointTurn(100, 300, false);
	//this is where is gets messy, we need to test the distance need to get over the bars and make sure that it is far enough to delive the goals
	// i will go with about 32.5 inches
	pidControl(120, 1622);
	mobileDown(120);   //make sure that the mobile goal distances are correct
	pidControl(120, -500);
	mobileUp(120);
	wait1Msec(5);
	pidControl(120, 1100);
	//hopefuly we have just scored a 20 point auton
	//lets move on to part 2
	//score 2-10 point goals with cones on them
	// we will go for the player side goal first
	wait1Msec(5);
	pointTurn(120, 450, false); // it should point directly at the goal
	// we should move about 64 inches
	pidControl(120, 3176);
	//line up and pick up a cone and the goal
	//we will turn and take a goal form the speed stacker
	pointTurn(120, 150, true);
	secondaryLiftDown(60, 2000);
	pickUpCone();
	wait1Msec(500);
	secondaryLiftUp(120, 2600);
	pidControl(60, -80);
	pointTurn(120, 300, false);
	mobileDown(120);
	pidControl(80, 2228);
	mobileUp(120);
	secondaryLiftDown(120, 1500);
	releaseCone();
	wait1Msec(200);
	//now we go back to score in the 10 point zone
	pidControl(80, -2200);
	pointTurn(120, 600, false);
	pidControl(120, 1676);
	mobileDown(120);
	pidControl(120, -80);
	mobileUp(120);
	//we will now turn to make our voyage to cone 2 from the center
	// the turn should aproximatley aline with the 5 point line
	pointTurn(120, 450, true);
	pidControl(120, 2376);
	pointTurn(120, 600, true);
	mobileDown(120);
	pidControl(120, 1577);
	mobileUp(120);
	pidControl(80, 1577);
	pointTurn(120, 600, false);
	// now we should be line up to score 10 points..
	pidControl(120, 878);
	mobileDown(120);
	pidControl(80, -500);
	mobileUp(120);
	// we should have now scored a 10 point moblie goal
	// we will now attempt to get an additional 5 point mobile goal
	pointTurn(120, 450, true);
	pidControl(120, 779);
	pointTurn(120, 450, true);
	mobileDown(120);
	pidControl(120, 1677);
	mobileUp(120);
	//now that we have the cone, we will back out and drop the cone into the zone
	pidControl(80, -2625);
	pointTurn(120, 450, false);
	pidControl( 80, -290);
	mobileDown(120);
	pidControl(120, -400);
	mobileUP(120);
	//it will



	} else if (auton == 3) {
	lift(3000);
	//secondaryLiftUp(120, 3000);
	//pidControl(120,2M
	MobileDown(120);
	pidControl (120, 2500);
	MobileUp(120);
	pidControl (-120, 2400);
	pointTurn(120, 1200, false);
	pidControl(120, 500);
	pointTurn(120, 200, false);
	pidControl(120,100);
	MobileDown(120);
	pidControl(-120, 50);
	MobileUp(120);
	pidControl(-120, 700);

	// some other wierd auton such as cone stacking

}
//move(120, 1257);
//pickupCone();
//wait1Msec(5000);
//move(120, 1257);
//pointTurn(120, 1200, true);
//toggleMobileIntake(1200);
//releaseCone();
//clubCantEvenHandleMeRightNow(2500);
//setLCDPosition(0,0);
//displayNextLCDNumber(SensorValue(liftPot));
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
//Variables for the lift with PID
int lastLiftLeft = 0;
int lastLiftRight = 0;
float pidError = 0;
float lastPidError = 0;
float pidIntegral = 0;
float pidDerivative = 0;
float pidChange = 0;
bool liftRunning = false;
float pidLiftError(int speedLeft, int speedRight) {
	float kP = 1.5;
	float kI = 0.04;
	float kD = 0.05;

	pidError = speedLeft - speedRight;
	//Integral part
	if (abs(pidIntegral) < 50) {
		pidIntegral = pidError - (pidError - lastPidError) / 2 + pidIntegral;
	}
	else {
		pidIntegral = 0;
	}
	//Derivative part
	pidDerivative = pidError - lastPidError;
	//Calculate change
	pidChange = kP*pidError + kI*pidIntegral + kD*pidDerivative;
	return pidChange;
}
task usercontrol()
{
// User control code here, inside the loop
int x = 0;
int y = 0;

while (1==1){
	clearLCDLine(0);
	setLCDPosition(0,0);
	displayNextLCDNumber(SensorValue(armPot));
	//Code for buttons controlling the cone grabber
	if (vexRT[Btn6U] == 1){
		motor[port1] = -128;
		} else if (vexRT[Btn6D] == 1){

		motor[port1] = 128;
		} else {
		motor[port1] = -13;
	}

	//Code for buttons controlling the lift
	if (vexRT[Btn5U] == 1) {
		if (!liftRunning) {
			motor[port7] = 120;
			motor[port8] = 120;
			motor[port9] = 120;
			lastLiftLeft = SensorValue(liftPot);
			lastLiftRight = SensorValue(liftPotRight);
			liftRunning = true;
		}
		else {
			float error = pidLiftError(SensorValue(liftPot) - lastLiftLeft, SensorValue(liftPotRight) - lastLiftRight);
			motor[port8] = 120 + error;
			motor[port9] = 120 + error;
		}
	}
	else if (vexRT[Btn5D] == 1) {
		if (!liftRunning) {
			motor[port7] = -120;
			motor[port8] = -120;
			motor[port9] = -120;
			lastLiftLeft = SensorValue(liftPot);
			lastLiftRight = SensorValue(liftPotRight);
			liftRunning = true;
		}
		else {
			float error = pidLiftError(SensorValue(liftPot) - lastLiftLeft, SensorValue(liftPotRight) - lastLiftRight);
			motor[port8] = -120 + error;
			motor[port9] = -120 + error;
		}
	}
	else {
		liftRunning = false;
		motor[port7] = 0;
		motor[port8] = 0;
		motor[port9] = 0;
	}
	//Code for buttons controlling the goal intake
	if (vexRT[Btn7U] == 1){
		motor[port6] = -128;

		} else if (vexRT[Btn7R] == 1){
		motor[port6] = 128;

		} else {
		motor[port6] = 0;
	}

	// finish this when the sensor values are known


	//Code for buttons controlling the reaching bar
	if (vexRT[Btn8R] == 1){
		motor[port10] = 128;
		} else if (vexRT[Btn8U] == 1){
		motor[port10] = -128;
		} else if (sensorvalue(armPot) < 1660 ){
		motor[port10] = -10;
		} else{
		motor[port10] = 0;

	}



	//driving code
	int powerLeft = 0;
	int powerRight = 0;
	y = vexRT[Ch3];
	x = vexRT[Ch1];
	//Deadzone Filter to prevent motor whining or drifting
	if (y < 20 && y > -20) {
		y = 0;
	}
	if (x < 20 && x > -20) {
		x = 0;
	}

	//Left Motor Calculator
	if (y >= 0) {
		if (x >= 0) {
			if (y >= x) {
				powerLeft = y;
				} else {
				powerLeft = x;
			}
			} else {
			powerLeft = y + x;
		}
		} else {
		if (x <= 0) {
			if (y <= x) {
				powerLeft = y;
				} else {
				powerLeft = x;
			}
			} else {
			powerLeft = y + x;
		}
	}

	//Right Motor Calculator
	if (y >= 0) {
		if (x <= 0) {
			if (y >= -x) {
				powerRight = y;
				} else {
				powerRight = -x;
			}
			} else {
			powerRight = y - x;
		}
		} else {
		if (x >= 0) {
			if (y <= -x) {
				powerRight = y;
				} else {
				powerRight = -x;
			}
			} else {
			powerRight = y - x;
		}
	}

	//Use power variables to control the motors
	motor[port2] = powerLeft;
	motor[port3] = powerRight;
	motor[port4] = powerLeft;
	motor[port5] = powerRight;
}
wait1Msec(25);
}
